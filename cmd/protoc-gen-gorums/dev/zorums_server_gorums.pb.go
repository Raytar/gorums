// Code generated by protoc-gen-gorums. DO NOT EDIT.

package dev

import (
	context "context"
	empty "github.com/golang/protobuf/ptypes/empty"
	gorums "github.com/relab/gorums"
	sync "sync"
)

// ZorumsService is the server-side API for the ZorumsService Service
type ZorumsService interface {
	GRPCCall(context.Context, *Request, func(*Response, error))
	QuorumCall(context.Context, *Request, func(*Response, error))
	QuorumCallPerNodeArg(context.Context, *Request, func(*Response, error))
	Multicast(context.Context, *Request)
	MulticastPerNodeArg(context.Context, *Request)
	Multicast2(context.Context, *Request)
	Multicast3(context.Context, *Request)
	Multicast4(context.Context, *empty.Empty)
	OrderingUnaryRPC(context.Context, *Request, func(*Response, error))
}

func RegisterZorumsServiceServer(srv *gorums.Server, impl ZorumsService) {
	srv.RegisterHandler(gRPCCallMethodID, func(ctx context.Context, in *gorums.Message, finished chan<- *gorums.Message) {
		req := in.Message.(*Request)
		once := new(sync.Once)
		f := func(resp *Response, err error) {
			once.Do(func() {
				finished <- gorums.WrapMessage(in.Metadata, resp, err)
			})
		}
		impl.GRPCCall(ctx, req, f)
	})
	srv.RegisterHandler(quorumCallMethodID, func(ctx context.Context, in *gorums.Message, finished chan<- *gorums.Message) {
		req := in.Message.(*Request)
		once := new(sync.Once)
		f := func(resp *Response, err error) {
			once.Do(func() {
				finished <- gorums.WrapMessage(in.Metadata, resp, err)
			})
		}
		impl.QuorumCall(ctx, req, f)
	})
	srv.RegisterHandler(quorumCallPerNodeArgMethodID, func(ctx context.Context, in *gorums.Message, finished chan<- *gorums.Message) {
		req := in.Message.(*Request)
		once := new(sync.Once)
		f := func(resp *Response, err error) {
			once.Do(func() {
				finished <- gorums.WrapMessage(in.Metadata, resp, err)
			})
		}
		impl.QuorumCallPerNodeArg(ctx, req, f)
	})
	srv.RegisterHandler(multicastMethodID, func(ctx context.Context, in *gorums.Message, _ chan<- *gorums.Message) {
		req := in.Message.(*Request)
		impl.Multicast(ctx, req)
	})
	srv.RegisterHandler(multicastPerNodeArgMethodID, func(ctx context.Context, in *gorums.Message, _ chan<- *gorums.Message) {
		req := in.Message.(*Request)
		impl.MulticastPerNodeArg(ctx, req)
	})
	srv.RegisterHandler(multicast2MethodID, func(ctx context.Context, in *gorums.Message, _ chan<- *gorums.Message) {
		req := in.Message.(*Request)
		impl.Multicast2(ctx, req)
	})
	srv.RegisterHandler(multicast3MethodID, func(ctx context.Context, in *gorums.Message, _ chan<- *gorums.Message) {
		req := in.Message.(*Request)
		impl.Multicast3(ctx, req)
	})
	srv.RegisterHandler(multicast4MethodID, func(ctx context.Context, in *gorums.Message, _ chan<- *gorums.Message) {
		req := in.Message.(*empty.Empty)
		impl.Multicast4(ctx, req)
	})
	srv.RegisterHandler(orderingUnaryRPCMethodID, func(ctx context.Context, in *gorums.Message, finished chan<- *gorums.Message) {
		req := in.Message.(*Request)
		once := new(sync.Once)
		f := func(resp *Response, err error) {
			once.Do(func() {
				finished <- gorums.WrapMessage(in.Metadata, resp, err)
			})
		}
		impl.OrderingUnaryRPC(ctx, req, f)
	})
}
