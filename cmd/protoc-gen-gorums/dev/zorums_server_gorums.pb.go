// Code generated by protoc-gen-gorums. DO NOT EDIT.
// versions:
// 	protoc-gen-gorums v0.5.0-devel
// 	protoc            v3.16.0
// source: zorums.proto

package dev

import (
	context "context"
	gorums "github.com/relab/gorums"
	emptypb "google.golang.org/protobuf/types/known/emptypb"
	sync "sync"
)

const (
	// Verify that this generated code is sufficiently up-to-date.
	_ = gorums.EnforceVersion(5 - gorums.MinVersion)
	// Verify that the gorums runtime is sufficiently up-to-date.
	_ = gorums.EnforceVersion(gorums.MaxVersion - 5)
)

// ZorumsService is the server-side API for the ZorumsService Service
type ZorumsService interface {
	GRPCCall(ctx context.Context, request *Request, release func()) (response *Response, err error)
	QuorumCall(ctx context.Context, request *Request, release func()) (response *Response, err error)
	QuorumCallPerNodeArg(ctx context.Context, request *Request, release func()) (response *Response, err error)
	QuorumCallCustomReturnType(ctx context.Context, request *Request, release func()) (response *Response, err error)
	QuorumCallCombo(ctx context.Context, request *Request, release func()) (response *Response, err error)
	QuorumCallEmpty(ctx context.Context, request *emptypb.Empty, release func()) (response *Response, err error)
	QuorumCallEmpty2(ctx context.Context, request *Request, release func()) (response *emptypb.Empty, err error)
	Multicast(ctx context.Context, request *Request, release func())
	MulticastPerNodeArg(ctx context.Context, request *Request, release func())
	Multicast2(ctx context.Context, request *Request, release func())
	Multicast3(ctx context.Context, request *Request, release func())
	Multicast4(ctx context.Context, request *emptypb.Empty, release func())
	QuorumCallAsync(ctx context.Context, request *Request, release func()) (response *Response, err error)
	QuorumCallAsyncPerNodeArg(ctx context.Context, request *Request, release func()) (response *Response, err error)
	QuorumCallAsyncCustomReturnType(ctx context.Context, request *Request, release func()) (response *Response, err error)
	QuorumCallAsyncCombo(ctx context.Context, request *Request, release func()) (response *Response, err error)
	QuorumCallAsync2(ctx context.Context, request *Request, release func()) (response *Response, err error)
	QuorumCallAsyncEmpty(ctx context.Context, request *Request, release func()) (response *emptypb.Empty, err error)
	QuorumCallAsyncEmpty2(ctx context.Context, request *emptypb.Empty, release func()) (response *Response, err error)
	Correctable(ctx context.Context, request *Request, release func()) (response *Response, err error)
	CorrectablePerNodeArg(ctx context.Context, request *Request, release func()) (response *Response, err error)
	CorrectableCustomReturnType(ctx context.Context, request *Request, release func()) (response *Response, err error)
	CorrectableCombo(ctx context.Context, request *Request, release func()) (response *Response, err error)
	CorrectableEmpty(ctx context.Context, request *Request, release func()) (response *emptypb.Empty, err error)
	CorrectableEmpty2(ctx context.Context, request *emptypb.Empty, release func()) (response *Response, err error)
	CorrectableStream(ctx context.Context, request *Request, release func()) (response *Response, err error)
	CorrectableStreamPerNodeArg(ctx context.Context, request *Request, release func()) (response *Response, err error)
	CorrectableStreamCustomReturnType(ctx context.Context, request *Request, release func()) (response *Response, err error)
	CorrectableStreamCombo(ctx context.Context, request *Request, release func()) (response *Response, err error)
	CorrectableStreamEmpty(ctx context.Context, request *Request, release func()) (response *emptypb.Empty, err error)
	CorrectableStreamEmpty2(ctx context.Context, request *emptypb.Empty, release func()) (response *Response, err error)
	Unicast(ctx context.Context, request *Request, release func())
	Unicast2(ctx context.Context, request *Request, release func())
}

func RegisterZorumsServiceServer(srv *gorums.Server, impl ZorumsService) {
	srv.RegisterHandler("dev.ZorumsService.GRPCCall", func(ctx context.Context, in *gorums.Message, finished chan<- *gorums.Message, mut *sync.Mutex) {
		req := in.Message.(*Request)
		once := new(sync.Once)
		release := func() { once.Do(mut.Unlock) }
		defer release()
		resp, err := impl.GRPCCall(ctx, req, release)
		select {
		case finished <- gorums.WrapMessage(in.Metadata, resp, err):
		case <-ctx.Done():
		}
	})
	srv.RegisterHandler("dev.ZorumsService.QuorumCall", func(ctx context.Context, in *gorums.Message, finished chan<- *gorums.Message, mut *sync.Mutex) {
		req := in.Message.(*Request)
		once := new(sync.Once)
		release := func() { once.Do(mut.Unlock) }
		defer release()
		resp, err := impl.QuorumCall(ctx, req, release)
		select {
		case finished <- gorums.WrapMessage(in.Metadata, resp, err):
		case <-ctx.Done():
		}
	})
	srv.RegisterHandler("dev.ZorumsService.QuorumCallPerNodeArg", func(ctx context.Context, in *gorums.Message, finished chan<- *gorums.Message, mut *sync.Mutex) {
		req := in.Message.(*Request)
		once := new(sync.Once)
		release := func() { once.Do(mut.Unlock) }
		defer release()
		resp, err := impl.QuorumCallPerNodeArg(ctx, req, release)
		select {
		case finished <- gorums.WrapMessage(in.Metadata, resp, err):
		case <-ctx.Done():
		}
	})
	srv.RegisterHandler("dev.ZorumsService.QuorumCallCustomReturnType", func(ctx context.Context, in *gorums.Message, finished chan<- *gorums.Message, mut *sync.Mutex) {
		req := in.Message.(*Request)
		once := new(sync.Once)
		release := func() { once.Do(mut.Unlock) }
		defer release()
		resp, err := impl.QuorumCallCustomReturnType(ctx, req, release)
		select {
		case finished <- gorums.WrapMessage(in.Metadata, resp, err):
		case <-ctx.Done():
		}
	})
	srv.RegisterHandler("dev.ZorumsService.QuorumCallCombo", func(ctx context.Context, in *gorums.Message, finished chan<- *gorums.Message, mut *sync.Mutex) {
		req := in.Message.(*Request)
		once := new(sync.Once)
		release := func() { once.Do(mut.Unlock) }
		defer release()
		resp, err := impl.QuorumCallCombo(ctx, req, release)
		select {
		case finished <- gorums.WrapMessage(in.Metadata, resp, err):
		case <-ctx.Done():
		}
	})
	srv.RegisterHandler("dev.ZorumsService.QuorumCallEmpty", func(ctx context.Context, in *gorums.Message, finished chan<- *gorums.Message, mut *sync.Mutex) {
		req := in.Message.(*emptypb.Empty)
		once := new(sync.Once)
		release := func() { once.Do(mut.Unlock) }
		defer release()
		resp, err := impl.QuorumCallEmpty(ctx, req, release)
		select {
		case finished <- gorums.WrapMessage(in.Metadata, resp, err):
		case <-ctx.Done():
		}
	})
	srv.RegisterHandler("dev.ZorumsService.QuorumCallEmpty2", func(ctx context.Context, in *gorums.Message, finished chan<- *gorums.Message, mut *sync.Mutex) {
		req := in.Message.(*Request)
		once := new(sync.Once)
		release := func() { once.Do(mut.Unlock) }
		defer release()
		resp, err := impl.QuorumCallEmpty2(ctx, req, release)
		select {
		case finished <- gorums.WrapMessage(in.Metadata, resp, err):
		case <-ctx.Done():
		}
	})
	srv.RegisterHandler("dev.ZorumsService.Multicast", func(ctx context.Context, in *gorums.Message, _ chan<- *gorums.Message, mut *sync.Mutex) {
		req := in.Message.(*Request)
		once := new(sync.Once)
		release := func() { once.Do(mut.Unlock) }
		defer release()
		impl.Multicast(ctx, req, release)
	})
	srv.RegisterHandler("dev.ZorumsService.MulticastPerNodeArg", func(ctx context.Context, in *gorums.Message, _ chan<- *gorums.Message, mut *sync.Mutex) {
		req := in.Message.(*Request)
		once := new(sync.Once)
		release := func() { once.Do(mut.Unlock) }
		defer release()
		impl.MulticastPerNodeArg(ctx, req, release)
	})
	srv.RegisterHandler("dev.ZorumsService.Multicast2", func(ctx context.Context, in *gorums.Message, _ chan<- *gorums.Message, mut *sync.Mutex) {
		req := in.Message.(*Request)
		once := new(sync.Once)
		release := func() { once.Do(mut.Unlock) }
		defer release()
		impl.Multicast2(ctx, req, release)
	})
	srv.RegisterHandler("dev.ZorumsService.Multicast3", func(ctx context.Context, in *gorums.Message, _ chan<- *gorums.Message, mut *sync.Mutex) {
		req := in.Message.(*Request)
		once := new(sync.Once)
		release := func() { once.Do(mut.Unlock) }
		defer release()
		impl.Multicast3(ctx, req, release)
	})
	srv.RegisterHandler("dev.ZorumsService.Multicast4", func(ctx context.Context, in *gorums.Message, _ chan<- *gorums.Message, mut *sync.Mutex) {
		req := in.Message.(*emptypb.Empty)
		once := new(sync.Once)
		release := func() { once.Do(mut.Unlock) }
		defer release()
		impl.Multicast4(ctx, req, release)
	})
	srv.RegisterHandler("dev.ZorumsService.QuorumCallAsync", func(ctx context.Context, in *gorums.Message, finished chan<- *gorums.Message, mut *sync.Mutex) {
		req := in.Message.(*Request)
		once := new(sync.Once)
		release := func() { once.Do(mut.Unlock) }
		defer release()
		resp, err := impl.QuorumCallAsync(ctx, req, release)
		select {
		case finished <- gorums.WrapMessage(in.Metadata, resp, err):
		case <-ctx.Done():
		}
	})
	srv.RegisterHandler("dev.ZorumsService.QuorumCallAsyncPerNodeArg", func(ctx context.Context, in *gorums.Message, finished chan<- *gorums.Message, mut *sync.Mutex) {
		req := in.Message.(*Request)
		once := new(sync.Once)
		release := func() { once.Do(mut.Unlock) }
		defer release()
		resp, err := impl.QuorumCallAsyncPerNodeArg(ctx, req, release)
		select {
		case finished <- gorums.WrapMessage(in.Metadata, resp, err):
		case <-ctx.Done():
		}
	})
	srv.RegisterHandler("dev.ZorumsService.QuorumCallAsyncCustomReturnType", func(ctx context.Context, in *gorums.Message, finished chan<- *gorums.Message, mut *sync.Mutex) {
		req := in.Message.(*Request)
		once := new(sync.Once)
		release := func() { once.Do(mut.Unlock) }
		defer release()
		resp, err := impl.QuorumCallAsyncCustomReturnType(ctx, req, release)
		select {
		case finished <- gorums.WrapMessage(in.Metadata, resp, err):
		case <-ctx.Done():
		}
	})
	srv.RegisterHandler("dev.ZorumsService.QuorumCallAsyncCombo", func(ctx context.Context, in *gorums.Message, finished chan<- *gorums.Message, mut *sync.Mutex) {
		req := in.Message.(*Request)
		once := new(sync.Once)
		release := func() { once.Do(mut.Unlock) }
		defer release()
		resp, err := impl.QuorumCallAsyncCombo(ctx, req, release)
		select {
		case finished <- gorums.WrapMessage(in.Metadata, resp, err):
		case <-ctx.Done():
		}
	})
	srv.RegisterHandler("dev.ZorumsService.QuorumCallAsync2", func(ctx context.Context, in *gorums.Message, finished chan<- *gorums.Message, mut *sync.Mutex) {
		req := in.Message.(*Request)
		once := new(sync.Once)
		release := func() { once.Do(mut.Unlock) }
		defer release()
		resp, err := impl.QuorumCallAsync2(ctx, req, release)
		select {
		case finished <- gorums.WrapMessage(in.Metadata, resp, err):
		case <-ctx.Done():
		}
	})
	srv.RegisterHandler("dev.ZorumsService.QuorumCallAsyncEmpty", func(ctx context.Context, in *gorums.Message, finished chan<- *gorums.Message, mut *sync.Mutex) {
		req := in.Message.(*Request)
		once := new(sync.Once)
		release := func() { once.Do(mut.Unlock) }
		defer release()
		resp, err := impl.QuorumCallAsyncEmpty(ctx, req, release)
		select {
		case finished <- gorums.WrapMessage(in.Metadata, resp, err):
		case <-ctx.Done():
		}
	})
	srv.RegisterHandler("dev.ZorumsService.QuorumCallAsyncEmpty2", func(ctx context.Context, in *gorums.Message, finished chan<- *gorums.Message, mut *sync.Mutex) {
		req := in.Message.(*emptypb.Empty)
		once := new(sync.Once)
		release := func() { once.Do(mut.Unlock) }
		defer release()
		resp, err := impl.QuorumCallAsyncEmpty2(ctx, req, release)
		select {
		case finished <- gorums.WrapMessage(in.Metadata, resp, err):
		case <-ctx.Done():
		}
	})
	srv.RegisterHandler("dev.ZorumsService.Correctable", func(ctx context.Context, in *gorums.Message, finished chan<- *gorums.Message, mut *sync.Mutex) {
		req := in.Message.(*Request)
		once := new(sync.Once)
		release := func() { once.Do(mut.Unlock) }
		defer release()
		resp, err := impl.Correctable(ctx, req, release)
		select {
		case finished <- gorums.WrapMessage(in.Metadata, resp, err):
		case <-ctx.Done():
		}
	})
	srv.RegisterHandler("dev.ZorumsService.CorrectablePerNodeArg", func(ctx context.Context, in *gorums.Message, finished chan<- *gorums.Message, mut *sync.Mutex) {
		req := in.Message.(*Request)
		once := new(sync.Once)
		release := func() { once.Do(mut.Unlock) }
		defer release()
		resp, err := impl.CorrectablePerNodeArg(ctx, req, release)
		select {
		case finished <- gorums.WrapMessage(in.Metadata, resp, err):
		case <-ctx.Done():
		}
	})
	srv.RegisterHandler("dev.ZorumsService.CorrectableCustomReturnType", func(ctx context.Context, in *gorums.Message, finished chan<- *gorums.Message, mut *sync.Mutex) {
		req := in.Message.(*Request)
		once := new(sync.Once)
		release := func() { once.Do(mut.Unlock) }
		defer release()
		resp, err := impl.CorrectableCustomReturnType(ctx, req, release)
		select {
		case finished <- gorums.WrapMessage(in.Metadata, resp, err):
		case <-ctx.Done():
		}
	})
	srv.RegisterHandler("dev.ZorumsService.CorrectableCombo", func(ctx context.Context, in *gorums.Message, finished chan<- *gorums.Message, mut *sync.Mutex) {
		req := in.Message.(*Request)
		once := new(sync.Once)
		release := func() { once.Do(mut.Unlock) }
		defer release()
		resp, err := impl.CorrectableCombo(ctx, req, release)
		select {
		case finished <- gorums.WrapMessage(in.Metadata, resp, err):
		case <-ctx.Done():
		}
	})
	srv.RegisterHandler("dev.ZorumsService.CorrectableEmpty", func(ctx context.Context, in *gorums.Message, finished chan<- *gorums.Message, mut *sync.Mutex) {
		req := in.Message.(*Request)
		once := new(sync.Once)
		release := func() { once.Do(mut.Unlock) }
		defer release()
		resp, err := impl.CorrectableEmpty(ctx, req, release)
		select {
		case finished <- gorums.WrapMessage(in.Metadata, resp, err):
		case <-ctx.Done():
		}
	})
	srv.RegisterHandler("dev.ZorumsService.CorrectableEmpty2", func(ctx context.Context, in *gorums.Message, finished chan<- *gorums.Message, mut *sync.Mutex) {
		req := in.Message.(*emptypb.Empty)
		once := new(sync.Once)
		release := func() { once.Do(mut.Unlock) }
		defer release()
		resp, err := impl.CorrectableEmpty2(ctx, req, release)
		select {
		case finished <- gorums.WrapMessage(in.Metadata, resp, err):
		case <-ctx.Done():
		}
	})
	srv.RegisterHandler("dev.ZorumsService.CorrectableStream", func(ctx context.Context, in *gorums.Message, finished chan<- *gorums.Message, mut *sync.Mutex) {
		req := in.Message.(*Request)
		once := new(sync.Once)
		release := func() { once.Do(mut.Unlock) }
		defer release()
		resp, err := impl.CorrectableStream(ctx, req, release)
		select {
		case finished <- gorums.WrapMessage(in.Metadata, resp, err):
		case <-ctx.Done():
		}
	})
	srv.RegisterHandler("dev.ZorumsService.CorrectableStreamPerNodeArg", func(ctx context.Context, in *gorums.Message, finished chan<- *gorums.Message, mut *sync.Mutex) {
		req := in.Message.(*Request)
		once := new(sync.Once)
		release := func() { once.Do(mut.Unlock) }
		defer release()
		resp, err := impl.CorrectableStreamPerNodeArg(ctx, req, release)
		select {
		case finished <- gorums.WrapMessage(in.Metadata, resp, err):
		case <-ctx.Done():
		}
	})
	srv.RegisterHandler("dev.ZorumsService.CorrectableStreamCustomReturnType", func(ctx context.Context, in *gorums.Message, finished chan<- *gorums.Message, mut *sync.Mutex) {
		req := in.Message.(*Request)
		once := new(sync.Once)
		release := func() { once.Do(mut.Unlock) }
		defer release()
		resp, err := impl.CorrectableStreamCustomReturnType(ctx, req, release)
		select {
		case finished <- gorums.WrapMessage(in.Metadata, resp, err):
		case <-ctx.Done():
		}
	})
	srv.RegisterHandler("dev.ZorumsService.CorrectableStreamCombo", func(ctx context.Context, in *gorums.Message, finished chan<- *gorums.Message, mut *sync.Mutex) {
		req := in.Message.(*Request)
		once := new(sync.Once)
		release := func() { once.Do(mut.Unlock) }
		defer release()
		resp, err := impl.CorrectableStreamCombo(ctx, req, release)
		select {
		case finished <- gorums.WrapMessage(in.Metadata, resp, err):
		case <-ctx.Done():
		}
	})
	srv.RegisterHandler("dev.ZorumsService.CorrectableStreamEmpty", func(ctx context.Context, in *gorums.Message, finished chan<- *gorums.Message, mut *sync.Mutex) {
		req := in.Message.(*Request)
		once := new(sync.Once)
		release := func() { once.Do(mut.Unlock) }
		defer release()
		resp, err := impl.CorrectableStreamEmpty(ctx, req, release)
		select {
		case finished <- gorums.WrapMessage(in.Metadata, resp, err):
		case <-ctx.Done():
		}
	})
	srv.RegisterHandler("dev.ZorumsService.CorrectableStreamEmpty2", func(ctx context.Context, in *gorums.Message, finished chan<- *gorums.Message, mut *sync.Mutex) {
		req := in.Message.(*emptypb.Empty)
		once := new(sync.Once)
		release := func() { once.Do(mut.Unlock) }
		defer release()
		resp, err := impl.CorrectableStreamEmpty2(ctx, req, release)
		select {
		case finished <- gorums.WrapMessage(in.Metadata, resp, err):
		case <-ctx.Done():
		}
	})
	srv.RegisterHandler("dev.ZorumsService.Unicast", func(ctx context.Context, in *gorums.Message, _ chan<- *gorums.Message, mut *sync.Mutex) {
		req := in.Message.(*Request)
		once := new(sync.Once)
		release := func() { once.Do(mut.Unlock) }
		defer release()
		impl.Unicast(ctx, req, release)
	})
	srv.RegisterHandler("dev.ZorumsService.Unicast2", func(ctx context.Context, in *gorums.Message, _ chan<- *gorums.Message, mut *sync.Mutex) {
		req := in.Message.(*Request)
		once := new(sync.Once)
		release := func() { once.Do(mut.Unlock) }
		defer release()
		impl.Unicast2(ctx, req, release)
	})
}
