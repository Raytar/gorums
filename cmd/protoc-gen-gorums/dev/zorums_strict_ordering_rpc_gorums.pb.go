// Code generated by protoc-gen-gorums. DO NOT EDIT.

package dev

import (
	context "context"
	fmt "fmt"
	ptypes "github.com/golang/protobuf/ptypes"
	gorums "github.com/relab/gorums"
	grpc "google.golang.org/grpc"
)

func (n *Node) StrictOrderingUnaryRPC(ctx context.Context, in *Request, opts ...grpc.CallOption) (resp *Response, err error) {

	// get the ID which will be used to return the correct responses for a request
	msgID := n.strictOrdering.nextMsgID()

	// set up a channel to collect replies
	replies := make(chan *strictOrderingResult, 1)
	n.strictOrdering.recvQMut.Lock()
	n.strictOrdering.recvQ[msgID] = replies
	n.strictOrdering.recvQMut.Unlock()

	defer func() {
		// remove the replies channel when we are done
		n.strictOrdering.recvQMut.Lock()
		delete(n.strictOrdering.recvQ, msgID)
		n.strictOrdering.recvQMut.Unlock()
	}()

	data, err := ptypes.MarshalAny(in)
	if err != nil {
		return nil, fmt.Errorf("failed to marshal message: %w", err)
	}
	msg := &gorums.Message{
		ID:   msgID,
		URL:  "/dev.ZorumsService/StrictOrderingUnaryRPC",
		Data: data,
	}
	n.strictOrdering.sendQ <- msg

	select {
	case r := <-replies:
		if r.err != nil {
			return nil, r.err
		}
		reply := new(Response)
		err := ptypes.UnmarshalAny(r.reply, reply)
		if err != nil {
			return nil, fmt.Errorf("failed to unmarshal reply: %w", err)
		}
		return reply, nil
	case <-ctx.Done():
		return nil, ctx.Err()
	}
}

// StrictOrderingUnaryRPCHandler is the server API for the StrictOrderingUnaryRPC rpc.
type StrictOrderingUnaryRPCHandler interface {
	StrictOrderingUnaryRPC(*Request) *Response
}

// RegisterStrictOrderingUnaryRPCHandler sets the handler for StrictOrderingUnaryRPC.
func (s *GorumsServer) RegisterStrictOrderingUnaryRPCHandler(handler StrictOrderingUnaryRPCHandler) {
	s.srv.registerHandler("/dev.ZorumsService/StrictOrderingUnaryRPC", func(in *gorums.Message) *gorums.Message {
		req := new(Request)
		err := ptypes.UnmarshalAny(in.GetData(), req)
		// TODO: how to handle marshaling errors here
		if err != nil {
			return new(gorums.Message)
		}
		resp := handler.StrictOrderingUnaryRPC(req)
		data, err := ptypes.MarshalAny(resp)
		if err != nil {
			return new(gorums.Message)
		}
		return &gorums.Message{Data: data, URL: in.GetURL()}
	})
}
